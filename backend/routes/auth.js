import express from 'express';
import jwt from 'jsonwebtoken';
import { body, validationResult } from 'express-validator';
import bcrypt from 'bcryptjs';
import User from '../models/User.js';
import LoginHistory from '../models/LoginHistory.js';
import { loginLimiter } from '../middleware/rateLimiter.js';
import { authenticateToken } from '../middleware/auth.js';

const router = express.Router();

// Login with rate limiting
router.post('/login', loginLimiter, [
  body('email').isEmail().withMessage('Please enter a valid email'),
  body('password').notEmpty().withMessage('Password is required')
], async (req, res) => {
  try {
    console.log('üîç Login attempt:', req.body);
    
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      console.log('‚ùå Validation errors:', errors.array());
      return res.status(400).json({ errors: errors.array() });
    }

    const { email, password, rememberMe } = req.body;

    // Get client info
    const clientIP = req.ip || req.connection.remoteAddress || req.socket.remoteAddress;
    const userAgent = req.get('User-Agent');
    const deviceInfo = {
      browser: req.get('User-Agent'),
      platform: req.get('Platform') || 'Unknown',
      timestamp: new Date()
    };

    let user = null;
    let loginStatus = 'failed';
    let failureReason = null;

    try {
      // Find user in database
      user = await User.findOne({ where: { mem_email: email, mem_status: '1' } });
      if (!user) {
        // Don't log failed attempts for unknown users (to avoid foreign key issues)
        console.log(`‚ùå Login failed: Email not found - ${email} from ${clientIP}`);
        return res.status(400).json({ message: '‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡∏´‡∏£‡∏∑‡∏≠‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á' });
      }

      // Auto-detect role from database (no need to check role parameter)

      // Check password (using User's comparePassword method)
      console.log('üîê Checking password...');
      const isMatch = await user.comparePassword(password);
      console.log('üîê Password match result:', isMatch);
      
      if (!isMatch) {
        console.log('‚ùå Password mismatch - logging failed attempt');
        failureReason = 'Invalid password';
        await LoginHistory.create({
          member_id: user.mem_id,
          login_time: new Date(),
          ip_address: clientIP,
          user_agent: userAgent,
          device_info: deviceInfo,
          login_status: 'failed',
          failure_reason: 'Wrong password'
        });
        return res.status(400).json({ message: '‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡∏´‡∏£‡∏∑‡∏≠‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á' });
      }

      // Login successful - record it
      console.log('‚úÖ Password correct - logging success');
      loginStatus = 'success';
      await LoginHistory.create({
        member_id: user.mem_id,
        login_time: new Date(),
        ip_address: clientIP,
        user_agent: userAgent,
        device_info: deviceInfo,
        login_status: 'success',
        failure_reason: null
      });
      console.log('‚úÖ Success login_history recorded');

    } catch (dbError) {
      console.error('Database error during login:', dbError);
      return res.status(500).json({ message: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö' });
    }

    // Create token with different expiry based on rememberMe
    const tokenExpiry = rememberMe ? '30d' : '7d';
    const jwtSecret = process.env.JWT_SECRET || 'fallback_secret';
    
    if (!process.env.JWT_SECRET) {
      console.warn('‚ö†Ô∏è  JWT_SECRET not set! Using fallback secret.');
    }
    
    const token = jwt.sign(
      { 
        userId: user.mem_id,
        role: user.role,
        email: user.mem_email
      },
      jwtSecret,
      { expiresIn: tokenExpiry }
    );

    // Log login attempt
    console.log(`‚úÖ Login successful: ${user.mem_email} (${user.role}) from ${clientIP} - Remember: ${rememberMe}`);
    console.log(`üïí Token expires in: ${tokenExpiry}`);
    console.log(`üéØ JWT Token created for user ${user.mem_id}`);

    res.json({
      token,
      user: {
        id: user.mem_id,
        name: user.mem_name,
        email: user.mem_email,
        phone: user.mem_tel,
        role: user.role
      }
    });
  } catch (error) {
    console.error('‚ùå Login error:', error);
    res.status(500).json({ message: 'Server error' });
  }
});

// Register new student
router.post('/register', [
  body('mem_name').notEmpty().withMessage('‡∏ä‡∏∑‡πà‡∏≠-‡∏ô‡∏≤‡∏°‡∏™‡∏Å‡∏∏‡∏•‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô').isLength({ max: 30 }).withMessage('‡∏ä‡∏∑‡πà‡∏≠-‡∏ô‡∏≤‡∏°‡∏™‡∏Å‡∏∏‡∏•‡∏¢‡∏≤‡∏ß‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ'),
  body('mem_email').isEmail().withMessage('‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á').isLength({ max: 50 }).withMessage('‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡∏¢‡∏≤‡∏ß‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ'),
  body('mem_password').isLength({ min: 6, max: 30 }).withMessage('‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ 6-30 ‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£'),
  body('mem_card_id').isLength({ min: 13, max: 13 }).withMessage('‡πÄ‡∏•‡∏Ç‡∏ö‡∏±‡∏ï‡∏£‡∏õ‡∏£‡∏∞‡∏ä‡∏≤‡∏ä‡∏ô‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ 13 ‡∏´‡∏•‡∏±‡∏Å').isNumeric().withMessage('‡πÄ‡∏•‡∏Ç‡∏ö‡∏±‡∏ï‡∏£‡∏õ‡∏£‡∏∞‡∏ä‡∏≤‡∏ä‡∏ô‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç'),
  body('mem_addr').notEmpty().withMessage('‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô').isLength({ max: 255 }).withMessage('‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏¢‡∏≤‡∏ß‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ'),
  body('mem_tel').notEmpty().withMessage('‡πÄ‡∏ö‡∏≠‡∏£‡πå‡πÇ‡∏ó‡∏£‡∏®‡∏±‡∏û‡∏ó‡πå‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô').isLength({ max: 20 }).withMessage('‡πÄ‡∏ö‡∏≠‡∏£‡πå‡πÇ‡∏ó‡∏£‡∏®‡∏±‡∏û‡∏ó‡πå‡∏¢‡∏≤‡∏ß‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ'),
  body('role').optional().isIn(['Student', 'Manager', 'Admin']).withMessage('‡∏ö‡∏ó‡∏ö‡∏≤‡∏ó‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á')
], async (req, res) => {
  try {
    console.log('üéØ Registration attempt:', {
      email: req.body.mem_email,
      name: req.body.mem_name,
      role: req.body.role || 'Student'
    });

    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      console.log('‚ùå Validation errors:', errors.array());
      return res.status(400).json({ 
        message: '‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á',
        errors: errors.array() 
      });
    }

    const { 
      mem_name, 
      mem_email, 
      mem_password, 
      mem_card_id, 
      mem_addr, 
      mem_tel, 
      role = 'Student' 
    } = req.body;

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡∏ã‡πâ‡∏≥
    const existingUserByEmail = await User.findOne({ where: { mem_email } });
    if (existingUserByEmail) {
      console.log(`‚ùå Email already exists: ${mem_email}`);
      return res.status(400).json({ message: '‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡∏ô‡∏µ‡πâ‡∏ñ‡∏π‡∏Å‡πÉ‡∏ä‡πâ‡πÅ‡∏•‡πâ‡∏ß' });
    }

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏•‡∏Ç‡∏ö‡∏±‡∏ï‡∏£‡∏õ‡∏£‡∏∞‡∏ä‡∏≤‡∏ä‡∏ô‡∏ã‡πâ‡∏≥
    const existingUserByCardId = await User.findOne({ where: { mem_card_id } });
    if (existingUserByCardId) {
      console.log(`‚ùå Card ID already exists: ${mem_card_id}`);
      return res.status(400).json({ message: '‡πÄ‡∏•‡∏Ç‡∏ö‡∏±‡∏ï‡∏£‡∏õ‡∏£‡∏∞‡∏ä‡∏≤‡∏ä‡∏ô‡∏ô‡∏µ‡πâ‡∏ñ‡∏π‡∏Å‡πÉ‡∏ä‡πâ‡πÅ‡∏•‡πâ‡∏ß' });
    }

    // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÉ‡∏´‡∏°‡πà
    const newUser = await User.create({
      mem_name,
      mem_email,
      mem_password, // ‡∏à‡∏∞‡∏ñ‡∏π‡∏Å hash ‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥‡πÉ‡∏ô beforeCreate hook
      mem_card_id,
      mem_addr,
      mem_tel,
      mem_status: '1', // ‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô
      role: role // ‡πÉ‡∏ä‡πâ role ‡∏ó‡∏µ‡πà‡∏™‡πà‡∏á‡∏°‡∏≤ ‡∏´‡∏£‡∏∑‡∏≠ 'Student' ‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡πà‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô
    });

    console.log('‚úÖ User registered successfully:', {
      id: newUser.mem_id,
      email: newUser.mem_email,
      name: newUser.mem_name,
      role: newUser.role
    });

    // ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏•‡∏±‡∏ö (‡πÑ‡∏°‡πà‡∏£‡∏ß‡∏°‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô ‡πÅ‡∏•‡∏∞‡πÑ‡∏°‡πà‡∏°‡∏µ token ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ auto login)
    res.status(201).json({
      message: '‡∏™‡∏°‡∏±‡∏Ñ‡∏£‡∏™‡∏°‡∏≤‡∏ä‡∏¥‡∏Å‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏£‡∏∞‡∏ö‡∏ö',
      user: {
        id: newUser.mem_id,
        name: newUser.mem_name,
        email: newUser.mem_email,
        role: newUser.role,
        phone: newUser.mem_tel
      }
    });

  } catch (error) {
    console.error('‚ùå Registration error:', error);
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Sequelize validation errors
    if (error.name === 'SequelizeValidationError') {
      const messages = error.errors.map(err => err.message);
      return res.status(400).json({ 
        message: '‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á', 
        errors: messages 
      });
    }
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Unique constraint errors
    if (error.name === 'SequelizeUniqueConstraintError') {
      const field = error.errors[0]?.path;
      if (field === 'mem_email') {
        return res.status(400).json({ message: '‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡∏ô‡∏µ‡πâ‡∏ñ‡∏π‡∏Å‡πÉ‡∏ä‡πâ‡πÅ‡∏•‡πâ‡∏ß' });
      } else if (field === 'mem_card_id') {
        return res.status(400).json({ message: '‡πÄ‡∏•‡∏Ç‡∏ö‡∏±‡∏ï‡∏£‡∏õ‡∏£‡∏∞‡∏ä‡∏≤‡∏ä‡∏ô‡∏ô‡∏µ‡πâ‡∏ñ‡∏π‡∏Å‡πÉ‡∏ä‡πâ‡πÅ‡∏•‡πâ‡∏ß' });
      }
    }
    
    res.status(500).json({ message: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö' });
  }
});

// Verify identity for password reset
router.post('/verify-identity', [
  body('mem_email').isEmail().withMessage('‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á'),
  body('mem_card_id').isLength({ min: 13, max: 13 }).withMessage('‡πÄ‡∏•‡∏Ç‡∏ö‡∏±‡∏ï‡∏£‡∏õ‡∏£‡∏∞‡∏ä‡∏≤‡∏ä‡∏ô‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ 13 ‡∏´‡∏•‡∏±‡∏Å').isNumeric().withMessage('‡πÄ‡∏•‡∏Ç‡∏ö‡∏±‡∏ï‡∏£‡∏õ‡∏£‡∏∞‡∏ä‡∏≤‡∏ä‡∏ô‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç')
], async (req, res) => {
  try {
    console.log('üîç Verify identity attempt:', req.body);

    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      console.log('‚ùå Validation errors:', errors.array());
      return res.status(400).json({ 
        message: '‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á',
        errors: errors.array() 
      });
    }

    const { mem_email, mem_card_id } = req.body;

    // ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏î‡πâ‡∏ß‡∏¢‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡πÅ‡∏•‡∏∞‡πÄ‡∏•‡∏Ç‡∏ö‡∏±‡∏ï‡∏£‡∏õ‡∏£‡∏∞‡∏ä‡∏≤‡∏ä‡∏ô
    const user = await User.findOne({ 
      where: { 
        mem_email, 
        mem_card_id,
        mem_status: '1' 
      } 
    });

    if (!user) {
      console.log(`‚ùå Identity verification failed: ${mem_email} - ${mem_card_id}`);
      return res.status(400).json({ message: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡πÅ‡∏•‡∏∞‡πÄ‡∏•‡∏Ç‡∏ö‡∏±‡∏ï‡∏£‡∏õ‡∏£‡∏∞‡∏ä‡∏≤‡∏ä‡∏ô' });
    }

    console.log('‚úÖ Identity verified:', user.mem_email);

    res.json({
      message: '‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ï‡∏±‡∏ß‡∏ï‡∏ô‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à',
      user: {
        id: user.mem_id,
        name: user.mem_name,
        email: user.mem_email
      }
    });

  } catch (error) {
    console.error('‚ùå Verify identity error:', error);
    res.status(500).json({ message: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö' });
  }
});

// Reset password
router.post('/reset-password', [
  body('mem_email').isEmail().withMessage('‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á'),
  body('mem_card_id').isLength({ min: 13, max: 13 }).withMessage('‡πÄ‡∏•‡∏Ç‡∏ö‡∏±‡∏ï‡∏£‡∏õ‡∏£‡∏∞‡∏ä‡∏≤‡∏ä‡∏ô‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ 13 ‡∏´‡∏•‡∏±‡∏Å').isNumeric().withMessage('‡πÄ‡∏•‡∏Ç‡∏ö‡∏±‡∏ï‡∏£‡∏õ‡∏£‡∏∞‡∏ä‡∏≤‡∏ä‡∏ô‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç'),
  body('new_password').isLength({ min: 6, max: 30 }).withMessage('‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ 6-30 ‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£')
], async (req, res) => {
  try {
    console.log('üîê Reset password attempt:', {
      email: req.body.mem_email,
      cardId: req.body.mem_card_id
    });

    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      console.log('‚ùå Validation errors:', errors.array());
      return res.status(400).json({ 
        message: '‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á',
        errors: errors.array() 
      });
    }

    const { mem_email, mem_card_id, new_password } = req.body;

    // ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏î‡πâ‡∏ß‡∏¢‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡πÅ‡∏•‡∏∞‡πÄ‡∏•‡∏Ç‡∏ö‡∏±‡∏ï‡∏£‡∏õ‡∏£‡∏∞‡∏ä‡∏≤‡∏ä‡∏ô‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á
    const user = await User.findOne({ 
      where: { 
        mem_email, 
        mem_card_id,
        mem_status: '1' 
      } 
    });

    if (!user) {
      console.log(`‚ùå User not found for password reset: ${mem_email}`);
      return res.status(400).json({ message: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ' });
    }

    // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô (‡∏à‡∏∞‡∏ñ‡∏π‡∏Å hash ‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥‡πÉ‡∏ô beforeUpdate hook)
    await user.update({ mem_password: new_password });

    console.log('‚úÖ Password reset successful:', user.mem_email);

    res.json({
      message: '‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏£‡∏∞‡∏ö‡∏ö‡∏î‡πâ‡∏ß‡∏¢‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô‡πÉ‡∏´‡∏°‡πà'
    });

  } catch (error) {
    console.error('‚ùå Reset password error:', error);
    res.status(500).json({ message: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô' });
  }
});

// Get current user (requires auth middleware)
router.get('/me', authenticateToken, async (req, res) => {
  try {
    // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏Ñ‡∏£‡∏ö‡∏ñ‡πâ‡∏ß‡∏ô‡∏à‡∏≤‡∏Å database
    const user = await User.findByPk(req.user.mem_id, {
      attributes: { exclude: ['mem_password'] }
    });

    if (!user) {
      return res.status(404).json({ message: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ' });
    }

    console.log('‚úÖ /me endpoint - User data:', user.toJSON());
    
    res.json(user.toJSON());
  } catch (error) {
    console.error('‚ùå /me endpoint error:', error);
    res.status(500).json({ message: 'Server error' });
  }
});

export default router; 